package sflow

import (
	"bytes"
	"io"
	"reflect"
	"testing"

	"github.com/VerizonDigital/vflow/packet"
)

var TestRawPacketData = []byte{
	0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x05, 0xEE, 0x00, 0x00, 0x05, 0x6E, 0x00, 0x00, 0x00, 0x80, 0xC8, 0x8D, 0x83, 0xAA, 0x1C, 0x22, 0x3C, 0x8C,
	0x40, 0xBC, 0x32, 0x3F, 0x08, 0x00, 0x45, 0x00, 0x05, 0xDC, 0x53, 0x40, 0x40, 0x00, 0x3C, 0x06, 0xF3, 0x69, 0x0A, 0x17, 0x47, 0x5F, 0x0A, 0x99,
	0x96, 0x63, 0x97, 0xBF, 0x1F, 0x90, 0x23, 0xE6, 0xD6, 0xC3, 0x7B, 0xD5, 0x1D, 0x17, 0x80, 0x10, 0x01, 0xF4, 0xE5, 0xA8, 0x00, 0x00, 0x01, 0x01,
	0x08, 0x0A, 0x89, 0x6F, 0x46, 0x5E, 0x72, 0xB8, 0xC1, 0x1C, 0x3A, 0xB5, 0x58, 0x98, 0x10, 0xBC, 0x99, 0x53, 0x25, 0xC2, 0x1C, 0x00, 0xD5, 0x60,
	0xC1, 0xFE, 0x71, 0x94, 0xA0, 0xE0, 0x50, 0xAB, 0x89, 0x0B, 0x19, 0x2F, 0x4E, 0xAB, 0xF0, 0x7B, 0xE1, 0x00, 0xBC, 0xC9, 0xD0, 0x60, 0x51, 0x03,
	0x17, 0x03, 0x30, 0x3F, 0xC1, 0x08, 0x46, 0xFF, 0x84, 0x85, 0x69, 0x41, 0x42, 0x0D, 0x41, 0x0C, 0x0F, 0x6B, 0x40, 0xA1, 0x1E, 0x0F, 0x80, 0xEE,
}

func Test_decodeRawPacketHeader(t *testing.T) {
	type args struct {
		r      io.ReadSeeker
		length uint32
	}
	packeDecode := packet.NewPacket()
	packeData, _ := packeDecode.Decoder(TestRawPacketData[16:])
	tests := []struct {
		name    string
		args    args
		want    *SFRawPacketHeader
		wantErr bool
	}{
		{
			name: "Test decode raw packet header",
			args: args{
				r:      bytes.NewReader(TestRawPacketData),
				length: 0x90,
			},
			want: &SFRawPacketHeader{
				Tag:            0,
				Length:         0,
				HeaderProtocol: 1,
				FrameLength:    0x05EE,
				StrippedLength: 0x056E,
				HeaderLength:   0x80,
				data:           TestRawPacketData[16:],
				header:         packeData,
			},
			wantErr: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := decodeRawPacketHeader(tt.args.r, tt.args.length)
			if (err != nil) != tt.wantErr {
				t.Errorf("decodeRawPacketHeader() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("decodeRawPacketHeader() = %v, want %v", got, tt.want)
			}
		})
	}
}
